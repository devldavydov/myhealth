package cmdproc

// Code generated by "go generate". DO NOT EDIT!

import (
	"fmt"
	"time"
	"strconv"
	"strings"	

	"go.uber.org/zap"
	tele "gopkg.in/telebot.v4"
)	

func (r *CmdProcessor) process(c tele.Context, cmd string, userID int64) error {
	cmdParts := []string{}
	for _, part := range strings.Split(cmd, ",") {
		cmdParts = append(cmdParts, strings.Trim(part, " "))
	}

	if len(cmdParts) == 0 {
		r.logger.Error(
			"invalid command",
			zap.String("command", cmd),
			zap.Int64("userID", userID),
		)
		return c.Send(MsgErrInvalidCommand)
	}

	var resp []CmdResponse

	switch cmdParts[0] {
	case "w":
		resp = r._process_w("w", cmdParts[1:], userID)
	case "u":
		resp = r._process_u("u", cmdParts[1:], userID)
	case "h":
		resp = r._processHelp()
	default:
		r.logger.Error(
			"unknown command",
			zap.String("command", cmd),
			zap.Int64("userID", userID),
		)
		resp = NewSingleCmdResponse(MsgErrInvalidCommand)
	}	

	if r.debugMode {
		if err := c.Send("!!! ОТЛАДОЧНЫЙ РЕЖИМ !!!"); err != nil {
			return err
		}
	}

	for _, rItem := range resp {
		if err := c.Send(rItem.what, rItem.opts...); err != nil {
			return err
		}
	}

	return nil	
}

func (r *CmdProcessor) _process_w(baseCmd string, cmdParts []string, userID int64) []CmdResponse {
	if len(cmdParts) == 0 {
		r.logger.Error(
			"invalid command",
			zap.Strings("cmdParts", cmdParts),
			zap.Int64("userID", userID),
		)
		return NewSingleCmdResponse(MsgErrInvalidCommand)
	}

	var resp []CmdResponse

	switch cmdParts[0] {
	case "set":
		if len(cmdParts[1:]) != 2 {
			return NewSingleCmdResponse(MsgErrInvalidArgsCount)
		}
		
		cmdParts = cmdParts[1:]
		
		val0, err := parseTimestamp(r.tz, cmdParts[0])
		if err != nil {
			return argError("Дата")
		}
		
		val1, err := parseFloatG0(cmdParts[1])
		if err != nil {
			return argError("Значение")
		}
		
		resp = r.weightSetCommand(
			userID,
			val0,
			val1,
			)
				
	case "del":
		if len(cmdParts[1:]) != 1 {
			return NewSingleCmdResponse(MsgErrInvalidArgsCount)
		}
		
		cmdParts = cmdParts[1:]
		
		val0, err := parseTimestamp(r.tz, cmdParts[0])
		if err != nil {
			return argError("Дата")
		}
		
		resp = r.weightDelCommand(
			userID,
			val0,
			)
				
	case "list":
		if len(cmdParts[1:]) != 2 {
			return NewSingleCmdResponse(MsgErrInvalidArgsCount)
		}
		
		cmdParts = cmdParts[1:]
		
		val0, err := parseTimestamp(r.tz, cmdParts[0])
		if err != nil {
			return argError("С")
		}
		
		val1, err := parseTimestamp(r.tz, cmdParts[1])
		if err != nil {
			return argError("По")
		}
		
		resp = r.weightListCommand(
			userID,
			val0,
			val1,
			)
				
	case "h":
		return NewSingleCmdResponse(
			newCmdHelpBuilder(baseCmd, "Управление весом").
			addCmd(
				"Установка",
				"set",
				"Дата [Дата]",
				"Значение [Дробное>0]",
				).
			addCmd(
				"Удаление",
				"del",
				"Дата [Дата]",
				).
			addCmd(
				"Отчет",
				"list",
				"С [Дата]",
				"По [Дата]",
				).
			build(),
		optsHTML)

	default:
		r.logger.Error(
			"invalid command",
			zap.Strings("cmdParts", cmdParts),
			zap.Int64("userID", userID),
		)
		resp = NewSingleCmdResponse(MsgErrInvalidCommand)
	}

	return resp
}

func (r *CmdProcessor) _process_u(baseCmd string, cmdParts []string, userID int64) []CmdResponse {
	if len(cmdParts) == 0 {
		r.logger.Error(
			"invalid command",
			zap.Strings("cmdParts", cmdParts),
			zap.Int64("userID", userID),
		)
		return NewSingleCmdResponse(MsgErrInvalidCommand)
	}

	var resp []CmdResponse

	switch cmdParts[0] {
	case "set":
		if len(cmdParts[1:]) != 1 {
			return NewSingleCmdResponse(MsgErrInvalidArgsCount)
		}
		
		cmdParts = cmdParts[1:]
		
		val0, err := parseFloatG0(cmdParts[0])
		if err != nil {
			return argError("Лимит калорий")
		}
		
		resp = r.userSettingsSetCommand2(
			userID,
			val0,
			)
				
	case "st":
		resp = r.userSettingsSetTemplateCommand(userID)
				
	case "get":
		resp = r.userSettingsGetCommand(userID)
				
	case "h":
		return NewSingleCmdResponse(
			newCmdHelpBuilder(baseCmd, "Управление настройками пользователя").
			addCmd(
				"Установка",
				"set",
				"Лимит калорий [Дробное>0]",
				).
			addCmd(
				"Шаблон команды установки",
				"st",
				).
			addCmd(
				"Получение",
				"get",
				).
			build(),
		optsHTML)

	default:
		r.logger.Error(
			"invalid command",
			zap.Strings("cmdParts", cmdParts),
			zap.Int64("userID", userID),
		)
		resp = NewSingleCmdResponse(MsgErrInvalidCommand)
	}

	return resp
}

func (r *CmdProcessor) _processHelp() []CmdResponse {
	return nil
}

func parseTimestamp(tz *time.Location, arg string) (time.Time, error) {
	var t time.Time
	var err error

	if arg == "" {
		t = time.Now().In(tz)
	} else {
		t, err = time.Parse("02.01.2006", arg)
		if err != nil {
			return time.Time{}, err
		}
	}

	return time.Date(t.Year(), t.Month(), t.Day(), 0, 0, 0, 0, tz), nil
}

func parseFloatG0(arg string) (float64, error) {
	val, err := strconv.ParseFloat(arg, 64)
	if err != nil {
		return 0, err
	}

	if val <= 0 {
		return 0, fmt.Errorf("not above zero")
	}

	return val, nil
}

func argError(argName string) []CmdResponse {
	return NewSingleCmdResponse(fmt.Sprintf("%s: %s", MsgErrInvalidArg, argName))
}
