package cmdproc

// Code generated by "go generate". DO NOT EDIT!

import (
	"fmt"
	"time"
	"strconv"
	"strings"	

	m "github.com/devldavydov/myhealth/internal/common/messages"
	"github.com/devldavydov/myhealth/internal/storage"

	"go.uber.org/zap"
	tele "gopkg.in/telebot.v4"
)	

func (r *CmdProcessor) process(c tele.Context, cmd string, userID int64) error {
	cmdParts := []string{}
	for _, part := range strings.Split(cmd, ",") {
		cmdParts = append(cmdParts, strings.Trim(part, " "))
	}

	if len(cmdParts) == 0 {
		r.logger.Error(
			"invalid command",
			zap.String("command", cmd),
			zap.Int64("userID", userID),
		)
		return c.Send(m.MsgErrInvalidCommand)
	}

	var resp []CmdResponse

	switch cmdParts[0] {
	case "w":
		resp = r.process_w("w", cmdParts[1:], userID)
	case "u":
		resp = r.process_u("u", cmdParts[1:], userID)
	case "f":
		resp = r.process_f("f", cmdParts[1:], userID)
	case "x":
		resp = r.process_x("x", cmdParts[1:], userID)
	case "c":
		resp = r.process_c("c", cmdParts[1:], userID)
	case "b":
		resp = r.process_b("b", cmdParts[1:], userID)
	case "j":
		resp = r.process_j("j", cmdParts[1:], userID)
	case "s":
		resp = r.process_s("s", cmdParts[1:], userID)
	case "m":
		resp = r.process_m("m", cmdParts[1:], userID)
	case "h":
		resp = r.processHelp()
	default:
		r.logger.Error(
			"unknown command",
			zap.String("command", cmd),
			zap.Int64("userID", userID),
		)
		resp = NewSingleCmdResponse(m.MsgErrInvalidCommand)
	}	

	if r.debugMode {
		if err := c.Send("!!! ОТЛАДОЧНЫЙ РЕЖИМ !!!"); err != nil {
			return err
		}
	}

	for _, rItem := range resp {
		if err := c.Send(rItem.what, rItem.opts...); err != nil {
			return err
		}
	}

	return nil	
}

func (r *CmdProcessor) process_w(baseCmd string, cmdParts []string, userID int64) []CmdResponse {
	if len(cmdParts) == 0 {
		r.logger.Error(
			"invalid command",
			zap.Strings("cmdParts", cmdParts),
			zap.Int64("userID", userID),
		)
		return NewSingleCmdResponse(m.MsgErrInvalidCommand)
	}

	var resp []CmdResponse

	switch cmdParts[0] {
	case "set":
		if len(cmdParts[1:]) != 2 {
			return NewSingleCmdResponse(m.MsgErrInvalidArgsCount)
		}
		
		cmdParts = cmdParts[1:]
		
		val0, err := parseTimestamp(r.tz, cmdParts[0])
		if err != nil {
			return argError("Дата")
		}
		
		val1, err := parseFloatG0(cmdParts[1])
		if err != nil {
			return argError("Значение")
		}
		
		resp = r.weightSetCommand(
			userID,
			val0,
			val1,
			)
				
	case "del":
		if len(cmdParts[1:]) != 1 {
			return NewSingleCmdResponse(m.MsgErrInvalidArgsCount)
		}
		
		cmdParts = cmdParts[1:]
		
		val0, err := parseTimestamp(r.tz, cmdParts[0])
		if err != nil {
			return argError("Дата")
		}
		
		resp = r.weightDelCommand(
			userID,
			val0,
			)
				
	case "list":
		if len(cmdParts[1:]) != 2 {
			return NewSingleCmdResponse(m.MsgErrInvalidArgsCount)
		}
		
		cmdParts = cmdParts[1:]
		
		val0, err := parseTimestamp(r.tz, cmdParts[0])
		if err != nil {
			return argError("С")
		}
		
		val1, err := parseTimestamp(r.tz, cmdParts[1])
		if err != nil {
			return argError("По")
		}
		
		resp = r.weightListCommand(
			userID,
			val0,
			val1,
			)
				
	case "h":
		return NewSingleCmdResponse(
			newCmdHelpBuilder(baseCmd, "Управление весом").
			addCmd(
				"Установка",
				"set",
				"Дата [Дата]",
				"Значение [Дробное>0]",
				).
			addCmd(
				"Удаление",
				"del",
				"Дата [Дата]",
				).
			addCmd(
				"Отчет",
				"list",
				"С [Дата]",
				"По [Дата]",
				).
			build(),
		optsHTML)

	default:
		r.logger.Error(
			"invalid command",
			zap.Strings("cmdParts", cmdParts),
			zap.Int64("userID", userID),
		)
		resp = NewSingleCmdResponse(m.MsgErrInvalidCommand)
	}

	return resp
}

func (r *CmdProcessor) process_u(baseCmd string, cmdParts []string, userID int64) []CmdResponse {
	if len(cmdParts) == 0 {
		r.logger.Error(
			"invalid command",
			zap.Strings("cmdParts", cmdParts),
			zap.Int64("userID", userID),
		)
		return NewSingleCmdResponse(m.MsgErrInvalidCommand)
	}

	var resp []CmdResponse

	switch cmdParts[0] {
	case "set":
		if len(cmdParts[1:]) != 1 {
			return NewSingleCmdResponse(m.MsgErrInvalidArgsCount)
		}
		
		cmdParts = cmdParts[1:]
		
		val0, err := parseFloatG0(cmdParts[0])
		if err != nil {
			return argError("Лимит калорий")
		}
		
		resp = r.userSettingsSetCommand(
			userID,
			val0,
			)
				
	case "st":
		resp = r.userSettingsSetTemplateCommand(userID)
				
	case "get":
		resp = r.userSettingsGetCommand(userID)
				
	case "h":
		return NewSingleCmdResponse(
			newCmdHelpBuilder(baseCmd, "Управление настройками пользователя").
			addCmd(
				"Установка",
				"set",
				"Лимит калорий [Дробное>0]",
				).
			addCmd(
				"Шаблон команды установки",
				"st",
				).
			addCmd(
				"Получение",
				"get",
				).
			build(),
		optsHTML)

	default:
		r.logger.Error(
			"invalid command",
			zap.Strings("cmdParts", cmdParts),
			zap.Int64("userID", userID),
		)
		resp = NewSingleCmdResponse(m.MsgErrInvalidCommand)
	}

	return resp
}

func (r *CmdProcessor) process_f(baseCmd string, cmdParts []string, userID int64) []CmdResponse {
	if len(cmdParts) == 0 {
		r.logger.Error(
			"invalid command",
			zap.Strings("cmdParts", cmdParts),
			zap.Int64("userID", userID),
		)
		return NewSingleCmdResponse(m.MsgErrInvalidCommand)
	}

	var resp []CmdResponse

	switch cmdParts[0] {
	case "set":
		if len(cmdParts[1:]) != 8 {
			return NewSingleCmdResponse(m.MsgErrInvalidArgsCount)
		}
		
		cmdParts = cmdParts[1:]
		
		val0, err := parseStringG0(cmdParts[0])
		if err != nil {
			return argError("Ключ")
		}
		
		val1, err := parseStringG0(cmdParts[1])
		if err != nil {
			return argError("Наименование")
		}
		
		val2, err := parseStringGE0(cmdParts[2])
		if err != nil {
			return argError("Бренд")
		}
		
		val3, err := parseFloatGE0(cmdParts[3])
		if err != nil {
			return argError("ККал 100г")
		}
		
		val4, err := parseFloatGE0(cmdParts[4])
		if err != nil {
			return argError("Б 100г")
		}
		
		val5, err := parseFloatGE0(cmdParts[5])
		if err != nil {
			return argError("Ж 100г")
		}
		
		val6, err := parseFloatGE0(cmdParts[6])
		if err != nil {
			return argError("У 100г")
		}
		
		val7, err := parseStringGE0(cmdParts[7])
		if err != nil {
			return argError("Комментарий")
		}
		
		resp = r.foodSetCommand(
			userID,
			val0,
			val1,
			val2,
			val3,
			val4,
			val5,
			val6,
			val7,
			)
				
	case "st":
		if len(cmdParts[1:]) != 1 {
			return NewSingleCmdResponse(m.MsgErrInvalidArgsCount)
		}
		
		cmdParts = cmdParts[1:]
		
		val0, err := parseStringG0(cmdParts[0])
		if err != nil {
			return argError("Ключ")
		}
		
		resp = r.foodSetTemplateCommand(
			userID,
			val0,
			)
				
	case "find":
		if len(cmdParts[1:]) != 1 {
			return NewSingleCmdResponse(m.MsgErrInvalidArgsCount)
		}
		
		cmdParts = cmdParts[1:]
		
		val0, err := parseStringGE0(cmdParts[0])
		if err != nil {
			return argError("Подстрока")
		}
		
		resp = r.foodFindCommand(
			userID,
			val0,
			)
				
	case "calc":
		if len(cmdParts[1:]) != 2 {
			return NewSingleCmdResponse(m.MsgErrInvalidArgsCount)
		}
		
		cmdParts = cmdParts[1:]
		
		val0, err := parseStringG0(cmdParts[0])
		if err != nil {
			return argError("Ключ")
		}
		
		val1, err := parseFloatGE0(cmdParts[1])
		if err != nil {
			return argError("Вес")
		}
		
		resp = r.foodCalcCommand(
			userID,
			val0,
			val1,
			)
				
	case "list":
		resp = r.foodListCommand(userID)
				
	case "del":
		if len(cmdParts[1:]) != 1 {
			return NewSingleCmdResponse(m.MsgErrInvalidArgsCount)
		}
		
		cmdParts = cmdParts[1:]
		
		val0, err := parseStringG0(cmdParts[0])
		if err != nil {
			return argError("Ключ")
		}
		
		resp = r.foodDelCommand(
			userID,
			val0,
			)
				
	case "h":
		return NewSingleCmdResponse(
			newCmdHelpBuilder(baseCmd, "Управление едой").
			addCmd(
				"Установка",
				"set",
				"Ключ [Строка>0]",
				"Наименование [Строка>0]",
				"Бренд [Строка>=0]",
				"ККал 100г [Дробное>=0]",
				"Б 100г [Дробное>=0]",
				"Ж 100г [Дробное>=0]",
				"У 100г [Дробное>=0]",
				"Комментарий [Строка>=0]",
				).
			addCmd(
				"Шаблон команды установки",
				"st",
				"Ключ [Строка>0]",
				).
			addCmd(
				"Поиск",
				"find",
				"Подстрока [Строка>=0]",
				).
			addCmd(
				"Расчет КБЖУ",
				"calc",
				"Ключ [Строка>0]",
				"Вес [Дробное>=0]",
				).
			addCmd(
				"Список",
				"list",
				).
			addCmd(
				"Удаление",
				"del",
				"Ключ [Строка>0]",
				).
			build(),
		optsHTML)

	default:
		r.logger.Error(
			"invalid command",
			zap.Strings("cmdParts", cmdParts),
			zap.Int64("userID", userID),
		)
		resp = NewSingleCmdResponse(m.MsgErrInvalidCommand)
	}

	return resp
}

func (r *CmdProcessor) process_x(baseCmd string, cmdParts []string, userID int64) []CmdResponse {
	if len(cmdParts) == 0 {
		r.logger.Error(
			"invalid command",
			zap.Strings("cmdParts", cmdParts),
			zap.Int64("userID", userID),
		)
		return NewSingleCmdResponse(m.MsgErrInvalidCommand)
	}

	var resp []CmdResponse

	switch cmdParts[0] {
	case "backup":
		resp = r.maintenanceBackupCommand(userID)
				
	case "h":
		return NewSingleCmdResponse(
			newCmdHelpBuilder(baseCmd, "Управление служебными настройками").
			addCmd(
				"Бэкап",
				"backup",
				).
			build(),
		optsHTML)

	default:
		r.logger.Error(
			"invalid command",
			zap.Strings("cmdParts", cmdParts),
			zap.Int64("userID", userID),
		)
		resp = NewSingleCmdResponse(m.MsgErrInvalidCommand)
	}

	return resp
}

func (r *CmdProcessor) process_c(baseCmd string, cmdParts []string, userID int64) []CmdResponse {
	if len(cmdParts) == 0 {
		r.logger.Error(
			"invalid command",
			zap.Strings("cmdParts", cmdParts),
			zap.Int64("userID", userID),
		)
		return NewSingleCmdResponse(m.MsgErrInvalidCommand)
	}

	var resp []CmdResponse

	switch cmdParts[0] {
	case "c":
		if len(cmdParts[1:]) != 4 {
			return NewSingleCmdResponse(m.MsgErrInvalidArgsCount)
		}
		
		cmdParts = cmdParts[1:]
		
		val0, err := parseGender(cmdParts[0])
		if err != nil {
			return argError("Пол")
		}
		
		val1, err := parseFloatG0(cmdParts[1])
		if err != nil {
			return argError("Вес")
		}
		
		val2, err := parseFloatG0(cmdParts[2])
		if err != nil {
			return argError("Рост")
		}
		
		val3, err := parseFloatG0(cmdParts[3])
		if err != nil {
			return argError("Возраст")
		}
		
		resp = r.calcCalCalcCommand(
			userID,
			val0,
			val1,
			val2,
			val3,
			)
				
	case "h":
		return NewSingleCmdResponse(
			newCmdHelpBuilder(baseCmd, "Расчет лимита калорий").
			addCmd(
				"Расчет",
				"c",
				"Пол [Пол]",
				"Вес [Дробное>0]",
				"Рост [Дробное>0]",
				"Возраст [Дробное>0]",
				).
			build(),
		optsHTML)

	default:
		r.logger.Error(
			"invalid command",
			zap.Strings("cmdParts", cmdParts),
			zap.Int64("userID", userID),
		)
		resp = NewSingleCmdResponse(m.MsgErrInvalidCommand)
	}

	return resp
}

func (r *CmdProcessor) process_b(baseCmd string, cmdParts []string, userID int64) []CmdResponse {
	if len(cmdParts) == 0 {
		r.logger.Error(
			"invalid command",
			zap.Strings("cmdParts", cmdParts),
			zap.Int64("userID", userID),
		)
		return NewSingleCmdResponse(m.MsgErrInvalidCommand)
	}

	var resp []CmdResponse

	switch cmdParts[0] {
	case "set":
		if len(cmdParts[1:]) != 2 {
			return NewSingleCmdResponse(m.MsgErrInvalidArgsCount)
		}
		
		cmdParts = cmdParts[1:]
		
		val0, err := parseStringG0(cmdParts[0])
		if err != nil {
			return argError("Ключ")
		}
		
		val1, err := parseStringArr(cmdParts[1])
		if err != nil {
			return argError("Состав бандла")
		}
		
		resp = r.bundleSetCommand(
			userID,
			val0,
			val1,
			)
				
	case "st":
		if len(cmdParts[1:]) != 1 {
			return NewSingleCmdResponse(m.MsgErrInvalidArgsCount)
		}
		
		cmdParts = cmdParts[1:]
		
		val0, err := parseStringG0(cmdParts[0])
		if err != nil {
			return argError("Ключ")
		}
		
		resp = r.bundleSetTemplateCommand(
			userID,
			val0,
			)
				
	case "list":
		resp = r.bundleListCommand(userID)
				
	case "del":
		if len(cmdParts[1:]) != 1 {
			return NewSingleCmdResponse(m.MsgErrInvalidArgsCount)
		}
		
		cmdParts = cmdParts[1:]
		
		val0, err := parseStringG0(cmdParts[0])
		if err != nil {
			return argError("Ключ")
		}
		
		resp = r.bundleDelCommand(
			userID,
			val0,
			)
				
	case "h":
		return NewSingleCmdResponse(
			newCmdHelpBuilder(baseCmd, "Управление бандлами").
			addCmdWithComment(
				"Установка",
				"set",
				"Элемент бандла имеет формат 'Ключ бандла [Строка>0]' или 'Ключ еды [Строка>0]:Вес [Дробное>0]'",
				"Ключ [Строка>0]",
				"Состав бандла [Массив строк]",
				).	
			addCmd(
				"Шаблон команды установки",
				"st",
				"Ключ [Строка>0]",
				).
			addCmd(
				"Список",
				"list",
				).
			addCmd(
				"Удаление",
				"del",
				"Ключ [Строка>0]",
				).
			build(),
		optsHTML)

	default:
		r.logger.Error(
			"invalid command",
			zap.Strings("cmdParts", cmdParts),
			zap.Int64("userID", userID),
		)
		resp = NewSingleCmdResponse(m.MsgErrInvalidCommand)
	}

	return resp
}

func (r *CmdProcessor) process_j(baseCmd string, cmdParts []string, userID int64) []CmdResponse {
	if len(cmdParts) == 0 {
		r.logger.Error(
			"invalid command",
			zap.Strings("cmdParts", cmdParts),
			zap.Int64("userID", userID),
		)
		return NewSingleCmdResponse(m.MsgErrInvalidCommand)
	}

	var resp []CmdResponse

	switch cmdParts[0] {
	case "set":
		if len(cmdParts[1:]) != 4 {
			return NewSingleCmdResponse(m.MsgErrInvalidArgsCount)
		}
		
		cmdParts = cmdParts[1:]
		
		val0, err := parseTimestamp(r.tz, cmdParts[0])
		if err != nil {
			return argError("Дата")
		}
		
		val1, err := parseMeal(cmdParts[1])
		if err != nil {
			return argError("Прием пищи")
		}
		
		val2, err := parseStringG0(cmdParts[2])
		if err != nil {
			return argError("Ключ еды")
		}
		
		val3, err := parseFloatG0(cmdParts[3])
		if err != nil {
			return argError("Вес")
		}
		
		resp = r.journalSetCommand(
			userID,
			val0,
			val1,
			val2,
			val3,
			)
				
	case "sb":
		if len(cmdParts[1:]) != 3 {
			return NewSingleCmdResponse(m.MsgErrInvalidArgsCount)
		}
		
		cmdParts = cmdParts[1:]
		
		val0, err := parseTimestamp(r.tz, cmdParts[0])
		if err != nil {
			return argError("Дата")
		}
		
		val1, err := parseMeal(cmdParts[1])
		if err != nil {
			return argError("Прием пищи")
		}
		
		val2, err := parseStringG0(cmdParts[2])
		if err != nil {
			return argError("Ключ бандла")
		}
		
		resp = r.journalSetBundleCommand(
			userID,
			val0,
			val1,
			val2,
			)
				
	case "del":
		if len(cmdParts[1:]) != 3 {
			return NewSingleCmdResponse(m.MsgErrInvalidArgsCount)
		}
		
		cmdParts = cmdParts[1:]
		
		val0, err := parseTimestamp(r.tz, cmdParts[0])
		if err != nil {
			return argError("Дата")
		}
		
		val1, err := parseMeal(cmdParts[1])
		if err != nil {
			return argError("Прием пищи")
		}
		
		val2, err := parseStringG0(cmdParts[2])
		if err != nil {
			return argError("Ключ еды")
		}
		
		resp = r.journalDelCommand(
			userID,
			val0,
			val1,
			val2,
			)
				
	case "dm":
		if len(cmdParts[1:]) != 2 {
			return NewSingleCmdResponse(m.MsgErrInvalidArgsCount)
		}
		
		cmdParts = cmdParts[1:]
		
		val0, err := parseTimestamp(r.tz, cmdParts[0])
		if err != nil {
			return argError("Дата")
		}
		
		val1, err := parseMeal(cmdParts[1])
		if err != nil {
			return argError("Прием пищи")
		}
		
		resp = r.journalDelMealCommand(
			userID,
			val0,
			val1,
			)
				
	case "db":
		if len(cmdParts[1:]) != 3 {
			return NewSingleCmdResponse(m.MsgErrInvalidArgsCount)
		}
		
		cmdParts = cmdParts[1:]
		
		val0, err := parseTimestamp(r.tz, cmdParts[0])
		if err != nil {
			return argError("Дата")
		}
		
		val1, err := parseMeal(cmdParts[1])
		if err != nil {
			return argError("Прием пищи")
		}
		
		val2, err := parseStringG0(cmdParts[2])
		if err != nil {
			return argError("Ключ бандла")
		}
		
		resp = r.journalDelBundleCommand(
			userID,
			val0,
			val1,
			val2,
			)
				
	case "cp":
		if len(cmdParts[1:]) != 4 {
			return NewSingleCmdResponse(m.MsgErrInvalidArgsCount)
		}
		
		cmdParts = cmdParts[1:]
		
		val0, err := parseTimestamp(r.tz, cmdParts[0])
		if err != nil {
			return argError("Откуда")
		}
		
		val1, err := parseMeal(cmdParts[1])
		if err != nil {
			return argError("Откуда")
		}
		
		val2, err := parseTimestamp(r.tz, cmdParts[2])
		if err != nil {
			return argError("Куда")
		}
		
		val3, err := parseMeal(cmdParts[3])
		if err != nil {
			return argError("Куда")
		}
		
		resp = r.journalCopyCommand(
			userID,
			val0,
			val1,
			val2,
			val3,
			)
				
	case "rd":
		if len(cmdParts[1:]) != 1 {
			return NewSingleCmdResponse(m.MsgErrInvalidArgsCount)
		}
		
		cmdParts = cmdParts[1:]
		
		val0, err := parseTimestamp(r.tz, cmdParts[0])
		if err != nil {
			return argError("Дата")
		}
		
		resp = r.journalReportDayCommand(
			userID,
			val0,
			)
				
	case "rdc":
		if len(cmdParts[1:]) != 1 {
			return NewSingleCmdResponse(m.MsgErrInvalidArgsCount)
		}
		
		cmdParts = cmdParts[1:]
		
		val0, err := parseTimestamp(r.tz, cmdParts[0])
		if err != nil {
			return argError("Дата")
		}
		
		resp = r.journalReportDayCalloriesCommand(
			userID,
			val0,
			)
				
	case "tm":
		if len(cmdParts[1:]) != 2 {
			return NewSingleCmdResponse(m.MsgErrInvalidArgsCount)
		}
		
		cmdParts = cmdParts[1:]
		
		val0, err := parseTimestamp(r.tz, cmdParts[0])
		if err != nil {
			return argError("Дата")
		}
		
		val1, err := parseMeal(cmdParts[1])
		if err != nil {
			return argError("Прием пищи")
		}
		
		resp = r.journalTemplateMealCommand(
			userID,
			val0,
			val1,
			)
				
	case "fs":
		if len(cmdParts[1:]) != 1 {
			return NewSingleCmdResponse(m.MsgErrInvalidArgsCount)
		}
		
		cmdParts = cmdParts[1:]
		
		val0, err := parseStringG0(cmdParts[0])
		if err != nil {
			return argError("Ключ еды")
		}
		
		resp = r.journalFoodStatCommand(
			userID,
			val0,
			)
				
	case "sc":
		if len(cmdParts[1:]) != 2 {
			return NewSingleCmdResponse(m.MsgErrInvalidArgsCount)
		}
		
		cmdParts = cmdParts[1:]
		
		val0, err := parseTimestamp(r.tz, cmdParts[0])
		if err != nil {
			return argError("Дата")
		}
		
		val1, err := parseFloatG0(cmdParts[1])
		if err != nil {
			return argError("ККал")
		}
		
		resp = r.journalSetDayTotalCal(
			userID,
			val0,
			val1,
			)
				
	case "dc":
		if len(cmdParts[1:]) != 1 {
			return NewSingleCmdResponse(m.MsgErrInvalidArgsCount)
		}
		
		cmdParts = cmdParts[1:]
		
		val0, err := parseTimestamp(r.tz, cmdParts[0])
		if err != nil {
			return argError("Дата")
		}
		
		resp = r.journalDeleteDayTotalCal(
			userID,
			val0,
			)
				
	case "h":
		return NewSingleCmdResponse(
			newCmdHelpBuilder(baseCmd, "Управление журналом приема пищи").
			addCmd(
				"Установка",
				"set",
				"Дата [Дата]",
				"Прием пищи [Прием пищи]",
				"Ключ еды [Строка>0]",
				"Вес [Дробное>0]",
				).
			addCmd(
				"Установка бандлом",
				"sb",
				"Дата [Дата]",
				"Прием пищи [Прием пищи]",
				"Ключ бандла [Строка>0]",
				).
			addCmd(
				"Удаление",
				"del",
				"Дата [Дата]",
				"Прием пищи [Прием пищи]",
				"Ключ еды [Строка>0]",
				).
			addCmd(
				"Удаление приема пищи",
				"dm",
				"Дата [Дата]",
				"Прием пищи [Прием пищи]",
				).
			addCmd(
				"Удаление бандла из журнала",
				"db",
				"Дата [Дата]",
				"Прием пищи [Прием пищи]",
				"Ключ бандла [Строка>0]",
				).
			addCmd(
				"Копирование",
				"cp",
				"Откуда [Дата]",
				"Откуда [Прием пищи]",
				"Куда [Дата]",
				"Куда [Прием пищи]",
				).
			addCmd(
				"Отчет за день",
				"rd",
				"Дата [Дата]",
				).
			addCmd(
				"Отчет за день по ккал",
				"rdc",
				"Дата [Дата]",
				).
			addCmd(
				"Шаблоны команд приема пищи",
				"tm",
				"Дата [Дата]",
				"Прием пищи [Прием пищи]",
				).
			addCmd(
				"Статистика по еде",
				"fs",
				"Ключ еды [Строка>0]",
				).
			addCmd(
				"Установка значения потраченных ккал",
				"sc",
				"Дата [Дата]",
				"ККал [Дробное>0]",
				).
			addCmd(
				"Удаление значения потраченных ккал",
				"dc",
				"Дата [Дата]",
				).
			build(),
		optsHTML)

	default:
		r.logger.Error(
			"invalid command",
			zap.Strings("cmdParts", cmdParts),
			zap.Int64("userID", userID),
		)
		resp = NewSingleCmdResponse(m.MsgErrInvalidCommand)
	}

	return resp
}

func (r *CmdProcessor) process_s(baseCmd string, cmdParts []string, userID int64) []CmdResponse {
	if len(cmdParts) == 0 {
		r.logger.Error(
			"invalid command",
			zap.Strings("cmdParts", cmdParts),
			zap.Int64("userID", userID),
		)
		return NewSingleCmdResponse(m.MsgErrInvalidCommand)
	}

	var resp []CmdResponse

	switch cmdParts[0] {
	case "set":
		if len(cmdParts[1:]) != 4 {
			return NewSingleCmdResponse(m.MsgErrInvalidArgsCount)
		}
		
		cmdParts = cmdParts[1:]
		
		val0, err := parseStringG0(cmdParts[0])
		if err != nil {
			return argError("Ключ")
		}
		
		val1, err := parseStringG0(cmdParts[1])
		if err != nil {
			return argError("Наименование")
		}
		
		val2, err := parseStringG0(cmdParts[2])
		if err != nil {
			return argError("Единица измерения")
		}
		
		val3, err := parseStringGE0(cmdParts[3])
		if err != nil {
			return argError("Комментарий")
		}
		
		resp = r.sportSetCommand(
			userID,
			val0,
			val1,
			val2,
			val3,
			)
				
	case "st":
		if len(cmdParts[1:]) != 1 {
			return NewSingleCmdResponse(m.MsgErrInvalidArgsCount)
		}
		
		cmdParts = cmdParts[1:]
		
		val0, err := parseStringG0(cmdParts[0])
		if err != nil {
			return argError("Ключ")
		}
		
		resp = r.sportSetTemplateCommand(
			userID,
			val0,
			)
				
	case "del":
		if len(cmdParts[1:]) != 1 {
			return NewSingleCmdResponse(m.MsgErrInvalidArgsCount)
		}
		
		cmdParts = cmdParts[1:]
		
		val0, err := parseStringG0(cmdParts[0])
		if err != nil {
			return argError("Ключ")
		}
		
		resp = r.sportDelCommand(
			userID,
			val0,
			)
				
	case "list":
		resp = r.sportListCommand(userID)
				
	case "as":
		if len(cmdParts[1:]) != 4 {
			return NewSingleCmdResponse(m.MsgErrInvalidArgsCount)
		}
		
		cmdParts = cmdParts[1:]
		
		val0, err := parseTimestamp(r.tz, cmdParts[0])
		if err != nil {
			return argError("Дата")
		}
		
		val1, err := parseStringG0(cmdParts[1])
		if err != nil {
			return argError("Ключ спорта")
		}
		
		val2, err := parseFloatArr(cmdParts[2])
		if err != nil {
			return argError("Подходы")
		}
		
		val3, err := parseStringGE0(cmdParts[3])
		if err != nil {
			return argError("Комментарий")
		}
		
		resp = r.sportActivitySetCommand(
			userID,
			val0,
			val1,
			val2,
			val3,
			)
				
	case "ad":
		if len(cmdParts[1:]) != 2 {
			return NewSingleCmdResponse(m.MsgErrInvalidArgsCount)
		}
		
		cmdParts = cmdParts[1:]
		
		val0, err := parseTimestamp(r.tz, cmdParts[0])
		if err != nil {
			return argError("Дата")
		}
		
		val1, err := parseStringG0(cmdParts[1])
		if err != nil {
			return argError("Ключ спорта")
		}
		
		resp = r.sportActivityDelCommand(
			userID,
			val0,
			val1,
			)
				
	case "ar":
		if len(cmdParts[1:]) != 2 {
			return NewSingleCmdResponse(m.MsgErrInvalidArgsCount)
		}
		
		cmdParts = cmdParts[1:]
		
		val0, err := parseTimestamp(r.tz, cmdParts[0])
		if err != nil {
			return argError("С")
		}
		
		val1, err := parseTimestamp(r.tz, cmdParts[1])
		if err != nil {
			return argError("По")
		}
		
		resp = r.sportActivityReportCommand(
			userID,
			val0,
			val1,
			)
				
	case "h":
		return NewSingleCmdResponse(
			newCmdHelpBuilder(baseCmd, "Управление спортом").
			addCmd(
				"Установка",
				"set",
				"Ключ [Строка>0]",
				"Наименование [Строка>0]",
				"Единица измерения [Строка>0]",
				"Комментарий [Строка>=0]",
				).
			addCmd(
				"Шаблон команды установки",
				"st",
				"Ключ [Строка>0]",
				).
			addCmd(
				"Удаление",
				"del",
				"Ключ [Строка>0]",
				).
			addCmd(
				"Список",
				"list",
				).
			addCmd(
				"Установка активности",
				"as",
				"Дата [Дата]",
				"Ключ спорта [Строка>0]",
				"Подходы [Массив дробных чисел]",
				"Комментарий [Строка>=0]",
				).
			addCmd(
				"Удаление активности",
				"ad",
				"Дата [Дата]",
				"Ключ спорта [Строка>0]",
				).
			addCmd(
				"Отчет по активности",
				"ar",
				"С [Дата]",
				"По [Дата]",
				).
			build(),
		optsHTML)

	default:
		r.logger.Error(
			"invalid command",
			zap.Strings("cmdParts", cmdParts),
			zap.Int64("userID", userID),
		)
		resp = NewSingleCmdResponse(m.MsgErrInvalidCommand)
	}

	return resp
}

func (r *CmdProcessor) process_m(baseCmd string, cmdParts []string, userID int64) []CmdResponse {
	if len(cmdParts) == 0 {
		r.logger.Error(
			"invalid command",
			zap.Strings("cmdParts", cmdParts),
			zap.Int64("userID", userID),
		)
		return NewSingleCmdResponse(m.MsgErrInvalidCommand)
	}

	var resp []CmdResponse

	switch cmdParts[0] {
	case "set":
		if len(cmdParts[1:]) != 4 {
			return NewSingleCmdResponse(m.MsgErrInvalidArgsCount)
		}
		
		cmdParts = cmdParts[1:]
		
		val0, err := parseStringG0(cmdParts[0])
		if err != nil {
			return argError("Ключ")
		}
		
		val1, err := parseStringG0(cmdParts[1])
		if err != nil {
			return argError("Наименование")
		}
		
		val2, err := parseStringG0(cmdParts[2])
		if err != nil {
			return argError("Единица измерения")
		}
		
		val3, err := parseStringGE0(cmdParts[3])
		if err != nil {
			return argError("Комментарий")
		}
		
		resp = r.medSetCommand(
			userID,
			val0,
			val1,
			val2,
			val3,
			)
				
	case "st":
		if len(cmdParts[1:]) != 1 {
			return NewSingleCmdResponse(m.MsgErrInvalidArgsCount)
		}
		
		cmdParts = cmdParts[1:]
		
		val0, err := parseStringG0(cmdParts[0])
		if err != nil {
			return argError("Ключ")
		}
		
		resp = r.medSetTemplateCommand(
			userID,
			val0,
			)
				
	case "del":
		if len(cmdParts[1:]) != 1 {
			return NewSingleCmdResponse(m.MsgErrInvalidArgsCount)
		}
		
		cmdParts = cmdParts[1:]
		
		val0, err := parseStringG0(cmdParts[0])
		if err != nil {
			return argError("Ключ")
		}
		
		resp = r.medDelCommand(
			userID,
			val0,
			)
				
	case "list":
		resp = r.medListCommand(userID)
				
	case "is":
		if len(cmdParts[1:]) != 3 {
			return NewSingleCmdResponse(m.MsgErrInvalidArgsCount)
		}
		
		cmdParts = cmdParts[1:]
		
		val0, err := parseTimestamp(r.tz, cmdParts[0])
		if err != nil {
			return argError("Дата")
		}
		
		val1, err := parseStringG0(cmdParts[1])
		if err != nil {
			return argError("Ключ медицины")
		}
		
		val2, err := parseFloatGE0(cmdParts[2])
		if err != nil {
			return argError("Значениe")
		}
		
		resp = r.medIndicatorSetCommand(
			userID,
			val0,
			val1,
			val2,
			)
				
	case "id":
		if len(cmdParts[1:]) != 2 {
			return NewSingleCmdResponse(m.MsgErrInvalidArgsCount)
		}
		
		cmdParts = cmdParts[1:]
		
		val0, err := parseTimestamp(r.tz, cmdParts[0])
		if err != nil {
			return argError("Дата")
		}
		
		val1, err := parseStringG0(cmdParts[1])
		if err != nil {
			return argError("Ключ спорта")
		}
		
		resp = r.medIndicatorDelCommand(
			userID,
			val0,
			val1,
			)
				
	case "ir":
		if len(cmdParts[1:]) != 2 {
			return NewSingleCmdResponse(m.MsgErrInvalidArgsCount)
		}
		
		cmdParts = cmdParts[1:]
		
		val0, err := parseTimestamp(r.tz, cmdParts[0])
		if err != nil {
			return argError("С")
		}
		
		val1, err := parseTimestamp(r.tz, cmdParts[1])
		if err != nil {
			return argError("По")
		}
		
		resp = r.medIndicatorReportCommand(
			userID,
			val0,
			val1,
			)
				
	case "h":
		return NewSingleCmdResponse(
			newCmdHelpBuilder(baseCmd, "Управление медициной").
			addCmd(
				"Установка",
				"set",
				"Ключ [Строка>0]",
				"Наименование [Строка>0]",
				"Единица измерения [Строка>0]",
				"Комментарий [Строка>=0]",
				).
			addCmd(
				"Шаблон команды установки",
				"st",
				"Ключ [Строка>0]",
				).
			addCmd(
				"Удаление",
				"del",
				"Ключ [Строка>0]",
				).
			addCmd(
				"Список",
				"list",
				).
			addCmd(
				"Установка показателя",
				"is",
				"Дата [Дата]",
				"Ключ медицины [Строка>0]",
				"Значениe [Дробное>=0]",
				).
			addCmd(
				"Удаление показателя",
				"id",
				"Дата [Дата]",
				"Ключ спорта [Строка>0]",
				).
			addCmd(
				"Отчет по показателям",
				"ir",
				"С [Дата]",
				"По [Дата]",
				).
			build(),
		optsHTML)

	default:
		r.logger.Error(
			"invalid command",
			zap.Strings("cmdParts", cmdParts),
			zap.Int64("userID", userID),
		)
		resp = NewSingleCmdResponse(m.MsgErrInvalidCommand)
	}

	return resp
}

func (r *CmdProcessor) processHelp() []CmdResponse {
	var sb strings.Builder
	sb.WriteString("<b>Команды помощи по разделам:</b>\n")
	sb.WriteString("<b>\u2022 w,h</b> - Вес\n")
	sb.WriteString("<b>\u2022 u,h</b> - Настройки пользователя\n")
	sb.WriteString("<b>\u2022 f,h</b> - Еда\n")
	sb.WriteString("<b>\u2022 x,h</b> - Cлужебные настройки\n")
	sb.WriteString("<b>\u2022 c,h</b> - Расчет лимита калорий\n")
	sb.WriteString("<b>\u2022 b,h</b> - Бандлы\n")
	sb.WriteString("<b>\u2022 j,h</b> - Журнал приема пищи\n")
	sb.WriteString("<b>\u2022 s,h</b> - Спорт\n")
	sb.WriteString("<b>\u2022 m,h</b> - Медицина\n")
	sb.WriteString("\n<b>Типы данных:</b>\n")
	sb.WriteString("<b>\u2022 Дата</b> - Дата в формате DD.MM.YYYY|пустая строка для текущей даты|целая дельта дней ± относительно текущей даты\n")
	sb.WriteString("<b>\u2022 Дробное>0</b> - Дробное число >0\n")
	sb.WriteString("<b>\u2022 Дробное>=0</b> - Дробное число >=0\n")
	sb.WriteString("<b>\u2022 Строка>0</b> - Строка длиной >0\n")
	sb.WriteString("<b>\u2022 Строка>=0</b> - Строка длиной >=0\n")
	sb.WriteString("<b>\u2022 Пол</b> - Пол - одно из значений m|f\n")
	sb.WriteString("<b>\u2022 Прием пищи</b> - Прием пищи - одно из значений завтрак|до обеда|обед|полдник|до ужина|ужин\n")
	sb.WriteString("<b>\u2022 Массив строк</b> - Массив строк (разделитель /, длина > 0)\n")
	sb.WriteString("<b>\u2022 Массив дробных чисел</b> - Массив дробных чисел (разделитель /, длина > 0)\n")
	return NewSingleCmdResponse(sb.String(), optsHTML)
}

func parseTimestamp(tz *time.Location, arg string) (time.Time, error) {
	var t time.Time

	// Arg empty string - now
	// Arg integer - add delta to now
	// Arg in date format

	if arg == "" {
		t = time.Now().In(tz)
	} else {
        delta, err := strconv.Atoi(arg)

		if err == nil {
			t = time.Now().In(tz)
			t = t.Add(time.Duration(delta) * 24 * time.Hour)
		} else {
			t, err = time.Parse("02.01.2006", arg)
			if err != nil {
				return time.Time{}, err
			}
		}
	}

	return time.Date(t.Year(), t.Month(), t.Day(), 0, 0, 0, 0, tz), nil
}

func parseFloatG0(arg string) (float64, error) {
	val, err := strconv.ParseFloat(arg, 64)
	if err != nil {
		return 0, err
	}

	if val <= 0 {
		return 0, fmt.Errorf("not above zero")
	}

	return val, nil
}

func parseFloatGE0(arg string) (float64, error) {
	val, err := strconv.ParseFloat(arg, 64)
	if err != nil {
		return 0, err
	}

	if val < 0 {
		return 0, fmt.Errorf("not above or equal zero")
	}

	return val, nil
}

func parseStringG0(arg string) (string, error) {
	if len(arg) == 0 {
		return "", fmt.Errorf("empty string")
	}
	
	return arg, nil
}

func parseStringGE0(arg string) (string, error) {
	return arg, nil
}

func parseGender(arg string) (string, error) {
	switch arg {
	case "m", "f":
		return arg, nil
	default:
		return "", fmt.Errorf("wrong gender")
	}
}

func parseMeal(arg string) (storage.Meal, error) {
	return storage.NewMealFromString(arg)
}

func parseStringArr(arg string) ([]string, error) {
	parts := []string{}
	for _, part := range strings.Split(arg, "/") {
		parts = append(parts, strings.Trim(part, " "))
	}

	if len(parts) == 0 {
		return nil, fmt.Errorf("empty array")
	}

	return parts, nil
}

func parseFloatArr(arg string) ([]float64, error) {
	parts := []float64{}
	for _, part := range strings.Split(arg, "/") {
		part = strings.Trim(part, " ")
		val, err := strconv.ParseFloat(part, 64)
		if err != nil {
			return nil, err
		}

		parts = append(parts, val)
	}

	if len(parts) == 0 {
		return nil, fmt.Errorf("empty array")
	}

	return parts, nil
}

func argError(argName string) []CmdResponse {
	return NewSingleCmdResponse(fmt.Sprintf("%s: %s", m.MsgErrInvalidArg, argName))
}

func formatTimestamp(ts time.Time) string {
	return ts.Format("02.01.2006")
}

type cmdHelpItem struct {
	label   string
	cmd     string
	comment string
	args    []string
}

type cmdHelpBuilder struct {
	baseCmd string
	label   string
	items   []cmdHelpItem
}

func newCmdHelpBuilder(baseCmd, label string) *cmdHelpBuilder {
	return &cmdHelpBuilder{baseCmd: baseCmd, label: label}
}

func (r *cmdHelpBuilder) addCmd(label, cmd string, args ...string) *cmdHelpBuilder {
	r.items = append(r.items, cmdHelpItem{
		label: label,
		cmd:   cmd,
		args:  args,
	})
	return r
}

func (r *cmdHelpBuilder) addCmdWithComment(label, cmd, comment string, args ...string) *cmdHelpBuilder {
	r.items = append(r.items, cmdHelpItem{
		label:   label,
		cmd:     cmd,
		comment: comment,
		args:    args,
	})
	return r
}

func (r *cmdHelpBuilder) build() string {
	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("<b>%s</b>\n", r.label))
	for i, item := range r.items {
		sb.WriteString(fmt.Sprintf("<b>\u2022 %s</b>\n", item.label))
		sb.WriteString(fmt.Sprintf("%s,%s", r.baseCmd, item.cmd))

		if len(item.args) > 0 {
			sb.WriteString(",\n")
		} else {
			sb.WriteString("\n")
		}

		for j, arg := range item.args {
			sArg := arg
			if strings.Contains(sArg, "|") {
				parts := strings.Split(sArg, "|")
				sArg = fmt.Sprintf("%s\n ИЛИ\n %s", parts[0], parts[1])
			}

			if j == len(item.args)-1 {
				sb.WriteString(fmt.Sprintf(" %s\n", sArg))
			} else {
				sb.WriteString(fmt.Sprintf(" %s,\n", sArg))
			}
		}

		if item.comment != "" {
			sb.WriteString(fmt.Sprintf("\n<i>Примечание</i>: %s\n", item.comment))
		}

		if i != len(r.items)-1 {
			sb.WriteString("\n")
		}
	}

	return sb.String()
}
