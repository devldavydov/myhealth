package main

import (
	"bytes"
	"flag"
	"log"
	"os"
	"text/template"

	"github.com/stretchr/testify/assert/yaml"
)

var tmpl = template.Must(template.New("").Parse(`package cmdproc

// Code generated by "go generate". DO NOT EDIT!

import (
	"time"
	"strings"

	"go.uber.org/zap"
	tele "gopkg.in/telebot.v4"
)	

const (
	_typeDate = "date"
	_typeFloatG0 = "floatG0"
)

func (r *CmdProcessor) process(c tele.Context, cmd string, userID int64) error {
	cmdParts := []string{}
	for _, part := range strings.Split(cmd, ",") {
		cmdParts = append(cmdParts, strings.Trim(part, " "))
	}

	if len(cmdParts) == 0 {
		r.logger.Error(
			"invalid command",
			zap.String("command", cmd),
			zap.Int64("userID", userID),
		)
		return c.Send(MsgErrInvalidCommand)
	}

	var resp []CmdResponse

	switch cmdParts[0] {
	{{ range .Config.Commands -}}
	case "{{ .Name }}":
		resp = r._process_{{ .Name }}("{{ .Name }}", cmdParts[1:], userID)
	{{ end -}}
	case "h":
		resp = r._processHelp()
	default:
		r.logger.Error(
			"unknown command",
			zap.String("command", cmd),
			zap.Int64("userID", userID),
		)
		resp = NewSingleCmdResponse(MsgErrInvalidCommand)
	}	

	if r.debugMode {
		if err := c.Send("!!! ОТЛАДОЧНЫЙ РЕЖИМ !!!"); err != nil {
			return err
		}
	}

	for _, rItem := range resp {
		if err := c.Send(rItem.what, rItem.opts...); err != nil {
			return err
		}
	}

	return nil	
}
{{ range .Config.Commands }}
func (r *CmdProcessor) _process_{{ .Name }}(baseCmd string, cmdParts []string, userID int64) []CmdResponse {
	if len(cmdParts) == 0 {
		r.logger.Error(
			"invalid command",
			zap.Strings("cmdParts", cmdParts),
			zap.Int64("userID", userID),
		)
		return NewSingleCmdResponse(MsgErrInvalidCommand)
	}

	var resp []CmdResponse

	switch cmdParts[0] {
	{{ range .SubCommands -}}
	case "{{ .Name }}":
	// Parse args
	// Call func
	// resp = r.{{ .Func }}()
	{{ end -}}
	default:
		r.logger.Error(
			"invalid command",
			zap.Strings("cmdParts", cmdParts),
			zap.Int64("userID", userID),
		)
		resp = NewSingleCmdResponse(MsgErrInvalidCommand)
	}

	return resp
}
{{ end }}
func (r *CmdProcessor) _processHelp() []CmdResponse {
	return nil
}

func (r *CmdProcessor) parseTimestamp(sTimestamp string) (time.Time, error) {
	var t time.Time
	var err error

	if sTimestamp == "" {
		t = time.Now().In(r.tz)
	} else {
		t, err = time.Parse("02.01.2006", sTimestamp)
		if err != nil {
			return time.Time{}, err
		}
	}

	return time.Date(t.Year(), t.Month(), t.Day(), 0, 0, 0, 0, r.tz), nil
}

func formatTimestamp(ts time.Time) string {
	return ts.Format("02.01.2006")
}
`))

type CommandProcessorConfig struct {
	Commands []Command  `yaml:"commands"`
	Types    []DataType `yaml:"types"`
}

type Command struct {
	Name             string       `yaml:"name"`
	Description      string       `yaml:"description"`
	DescriptionShort string       `yaml:"description_short"`
	SubCommands      []SubCommand `yaml:"subcommands"`
}

type SubCommand struct {
	Name        string `yaml:"name"`
	Func        string `yaml:"func"`
	Description string `yaml:"description"`
	Args        []Arg  `yaml:"args"`
}

type Arg struct {
	Name string `yaml:"name"`
	Type string `yaml:"type"`
}

type DataType struct {
	Name             string `yaml:"name"`
	Description      string `yaml:"description"`
	DescriptionShort string `yaml:"description_short"`
}

func main() {
	cfgFile := flag.String("in", "", "")
	outFileName := flag.String("out", "", "")
	flag.Parse()

	// Read config file
	cfgData, err := os.ReadFile(*cfgFile)
	if err != nil {
		log.Fatal(err)
	}

	cfg := CommandProcessorConfig{}
	if err := yaml.Unmarshal(cfgData, &cfg); err != nil {
		log.Fatal(err)
	}

	// Generate template
	type tmplData struct {
		Config *CommandProcessorConfig
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, tmplData{
		Config: &cfg,
	}); err != nil {
		log.Fatal(err)
	}

	// Save to out file
	if err := os.WriteFile(*outFileName, buf.Bytes(), os.ModePerm); err != nil {
		log.Fatal(err)
	}
}
